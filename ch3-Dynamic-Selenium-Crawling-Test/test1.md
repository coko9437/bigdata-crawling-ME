
---

### Selenium 기본 기능 마스터하기: 코드 분석 및 해설

이 코드들은 웹 브라우저 자동화 도구인 **Selenium**의 핵심 기능들을 하나씩 순서대로 학습할 수 있도록 구성된 훌륭한 예제 모음입니다. 각 코드 블록은 독립적으로 실행되며, 특정 기능을 명확하게 보여주는 데 초점을 맞추고 있습니다.

### 1. 코드 전체적인 흐름

자동화의 여정은 **"브라우저를 열고 → 원하는 페이지로 이동한 뒤 → 특정 요소를 찾아 → 클릭이나 입력 같은 행동을 하고 → 필요한 정보를 가져오거나 추가적인 행동을 한 후 → 브라우저를 닫는 것"**으로 요약할 수 있습니다. 이 코드들은 바로 이 흐름에 필요한 거의 모든 기술 조각들을 담고 있습니다.

1.  **브라우저 제어의 시작**: Selenium으로 Chrome 브라우저를 실행하고 원하는 웹사이트로 이동합니다.
2.  **웹 페이지 요소와의 상호작용**: 웹 페이지의 구성 요소(버튼, 입력창, 링크 등)를 찾는 방법을 배우고, 클릭하거나 키보드로 값을 입력하는 등 기본적인 조작을 실습합니다.
3.  **'기다림'의 미학**: 동적 웹 페이지에서 가장 중요한 개념 중 하나인 '대기(Wait)'의 종류와 필요성을 학습합니다.
4.  **고급 상호작용 및 제어**: 단순 클릭/입력을 넘어 스크롤, 새 창 열기, `iframe` 전환, 마우스 오버, 드래그 앤 드롭 등 복잡한 사용자 행동을 흉내 내는 방법을 익힙니다.
5.  **브라우저 정보 활용**: 쿠키를 조작하거나, 스크린샷을 찍고, 현재 페이지의 전체 HTML 소스를 가져오는 등 부가적인 기능들을 살펴봅니다.

---

### 2. 코드 상세 설명

각 코드 블록을 하나의 미션이라고 생각하고, 단계별로 어떤 일이 일어나는지 따라가 보겠습니다.

#### 2.1. 웹 드라이버 실행 및 페이지 열기 (기본 중의 기본)

*   **분기점**: `[자동화 시작] -> [크롬 브라우저 실행] -> [구글 페이지로 이동]`
*   **설명**: 자동화의 첫 단계는 우리가 제어할 웹 브라우저를 실행하는 것입니다. 이 코드에서는 Chrome 브라우저를 선택했습니다. `webdriver.Chrome()` 명령은 마치 우리가 바탕화면에서 크롬 아이콘을 더블 클릭하는 것과 같은 행동을 코드로 실행합니다. 그렇게 실행된 브라우저는 `driver`라는 변수(우리의 '리모컨')에 할당됩니다. `driver.get(...)`은 이 리모컨으로 브라우저의 주소창에 URL을 입력하고 Enter를 치는 것과 같습니다.
---
#### 2.2. 웹 페이지 요소 찾기 (`find_element`, `find_elements`)

*   **분기점**: `[구글 페이지로 이동] -> [검색창 하나 찾기] -> [모든 링크 여러 개 찾기]`
*   **설명**: 웹 페이지와 상호작용하려면 먼저 조작할 대상을 '지목'해야 합니다. Selenium은 `find_element` (하나만 찾기)와 `find_elements` (조건에 맞는 모든 것 찾기)라는 두 가지 명령을 제공합니다. 마치 "이 방에서 '김민준'이라는 이름표를 단 **첫 번째 사람**을 찾아와!" (`find_element`) 또는 "'학생'이라는 이름표를 단 **모든 사람**을 찾아와!" (`find_elements`) 라고 시키는 것과 같습니다. 무엇으로 찾을지는 `name`, `tag name`, `class name`, `id`, `css selector` 등 다양하게 지정할 수 있습니다.
---
#### 2.3. 웹 페이지 로딩 대기 (`implicitly_wait`, `time.sleep`)

*   **분기점**: `[구글 페이지로 이동] -> [페이지가 로드될 때까지 기다리기]`
*   **설명**: 코드는 컴퓨터의 속도로 매우 빠르게 실행되지만, 인터넷을 통해 웹 페이지가 로드되는 데는 시간이 걸립니다. 페이지가 다 뜨기도 전에 요소를 찾으려고 하면 오류가 발생하겠죠. 그래서 '기다림'이 필수적입니다.
    *   `time.sleep(5)`: **무조건 5초 정지**. 가장 간단하지만 비효율적입니다. 페이지가 1초 만에 로드되어도 5초를 다 기다려야 합니다.
    *   `driver.implicitly_wait(10)`: **최대 10초까지 스마트하게 대기**. "앞으로 무언가를 찾을 때, 바로 안 보이면 최대 10초까지 기다려줘. 만약 1초 만에 찾으면 바로 다음으로 넘어가!"라고 `driver`에게 한 번만 알려주는 전역 설정입니다. 훨씬 효율적이죠.
---
#### 2.4. 특정 요소 클릭 (`click`)

*   **분기점**: `[구글 페이지로 이동] -> [Gmail 링크 찾기] -> [찾은 링크 마우스로 클릭]`
*   **설명**: `find_element`로 원하는 버튼이나 링크를 찾았다면, `.click()` 메서드를 호출하여 마우스 왼쪽 버튼으로 클릭하는 행동을 그대로 흉내 낼 수 있습니다. 이 예제에서는 '링크 텍스트'가 "Gmail"인 요소를 찾아 클릭합니다.
---
#### 2.5. 키보드 입력 (`send_keys`)

*   **분기점**: `[구글 페이지로 이동] -> [검색창 찾기] -> [검색창에 '날씨' 타이핑] -> [Enter 키 누르기]`
*   **설명**: `.send_keys()`는 키보드 입력을 위한 명령입니다. 검색창 요소를 찾은 뒤, `send_keys("날씨")`를 통해 글자를 입력하고, 이어서 `send_keys(Keys.RETURN)`으로 Enter 키를 누르는 동작까지 완벽하게 재현합니다.
---
#### 2.6. 자바스크립트 실행 (`execute_script`)

*   **분기점**: `[구글 뉴스 페이지로 이동] -> [자바스크립트 명령 실행] -> [페이지 맨 아래로 스크롤]`
*   **설명**: Selenium만으로 제어하기 어려운 동작(예: 부드러운 스크롤, 숨겨진 요소 조작)은 자바스크립트의 힘을 빌릴 수 있습니다. `driver.execute_script(...)`는 브라우저의 콘솔 창에 자바스크립트 코드를 직접 입력하고 실행하는 것과 같습니다. 여기서는 "페이지를 맨 아래까지 스크롤해라"라는 `window.scrollTo` 명령을 실행했습니다.
---
#### 2.7. 새 창 열기 및 핸들 전환 (`window_handles`)

*   **분기점**: `[구글 페이지] -> [새 탭으로 네이버 열기] -> [열려있는 모든 창 목록 확인] -> [다시 첫 번째 창(구글)으로 제어권 전환]`
*   **설명**: 브라우저에 여러 탭이나 창이 열려 있을 때, `driver` 리모컨은 한 번에 하나의 창만 제어할 수 있습니다. `driver.window_handles`는 현재 열린 모든 창의 '이름표' 목록을 가져옵니다. `driver.switch_to.window(이름표)` 명령을 통해 제어하고 싶은 창으로 리모컨의 채널을 돌릴 수 있습니다.
---
#### 2.8. 프레임 전환 (`switch_to.frame`)

*   **분기점**: `[w3schools 페이지로 이동] -> [페이지 안의 '액자(iframe)' 찾기] -> [액자 안으로 제어권 전환] -> [액자 안의 제목 텍스트 가져오기]`
*   **설명**: `iframe`은 '페이지 속의 작은 페이지'라고 생각하면 쉽습니다. 마치 액자 안에 다른 그림이 걸려있는 것과 같죠. 액자 밖에서는 액자 안의 그림을 만질 수 없듯, Selenium도 `iframe` 안의 요소를 바로 찾을 수 없습니다. `driver.switch_to.frame()`을 통해 '액자 안으로' 제어권을 옮겨야만 내부 요소에 접근할 수 있습니다.
---
#### 2.9. 쿠키 가져오기 및 설정 (`get_cookies`, `add_cookie`)

*   **분기점**: `[구글 페이지로 이동] -> [내 브라우저의 쿠키 추가] -> [새로고침] -> [추가된 쿠키 확인]`
*   **설명**: 쿠키는 웹사이트가 사용자의 정보를 브라우저에 저장하는 작은 데이터 조각입니다 (예: 자동 로그인 정보). Selenium을 이용하면 이 쿠키를 읽거나(`get_cookies`), 심지어 새로운 쿠키를 심을 수도(`add_cookie`) 있습니다. 이를 통해 로그인 과정을 건너뛰는 등의 고급 자동화가 가능해집니다.
---
#### 2.10. 스크린샷 저장 (`save_screenshot`)

*   **분기점**: `[구글 페이지로 이동] -> [현재 브라우저 화면 캡처] -> [파일로 저장]`
*   **설명**: 자동화 과정 중 특정 시점의 화면을 이미지 파일로 저장하고 싶을 때 사용합니다. 오류가 발생했을 때의 화면을 기록하거나, 작업의 결과를 시각적으로 증명할 때 매우 유용합니다.
---
#### 2.11. 특정 요소가 로드될 때까지 대기 (`WebDriverWait`) - 매우 중요!

*   **분기점**: `[구글 페이지로 이동] -> [검색창(name='q')이 '나타날 때까지' 최대 10초 대기] -> [나타나면 즉시 검색어 입력]`
*   **설명**: 2.3의 `implicitly_wait`보다 훨씬 강력하고 정교한 '명시적 대기'입니다. "최대 10초 동안 기다리되, **어떤 요소(By.NAME, "q")**가 **어떤 상태(presence_of_element_located: 그냥 나타나기만 하면 됨)**가 될 때까지 기다려줘" 라고 아주 구체적으로 명령할 수 있습니다. 동적 웹 페이지에서 가장 안정적으로 요소를 찾게 해주는 **최고의 방법**이며 실무에서 가장 권장됩니다.
---
#### 2.12. 마우스 이벤트 조작 (`ActionChains`)
---
*   **분기점**: `[구글 페이지로 이동] -> [Gmail 링크 찾기] -> [마우스 커서를 Gmail 링크 위로 이동 (클릭은 안 함)]`
*   **설명**: 클릭이나 타이핑 외에 마우스 오버(hover), 드래그 앤 드롭, 우클릭 등 복잡한 마우스 행동을 시뮬레이션할 때 사용합니다. `ActionChains`는 '행동 시나리오'를 만드는 것과 같습니다. "마우스를 저 요소로 옮겨라"(`move_to_element`) 라는 시나리오를 짠 뒤, `.perform()`을 호출하여 실제로 실행합니다.
---
#### 2.13. 입력값 삭제 (`clear`)

*   **분기점**: `[구글 페이지로 이동] -> [검색창에 텍스트 입력] -> [잠시 후 입력된 텍스트 모두 지우기]`
*   **설명**: `send_keys`로 입력한 텍스트를 지울 때 사용합니다. 입력 필드의 내용을 깨끗하게 비우는 간단하지만 유용한 기능입니다.
---
#### 2.14. 브라우저 창 크기 조절 (`set_window_size`)
---
*   **분기점**: `[구글 페이지로 이동] -> [브라우저 창 크기를 가로 1500, 세로 768 픽셀로 변경]`
*   **설명**: 웹사이트는 브라우저 창 크기에 따라 레이아웃이 바뀌는 '반응형 디자인'인 경우가 많습니다. 특정 레이아웃에서만 보이는 요소를 테스트하거나, 일관된 환경에서 스크린샷을 찍고 싶을 때 창 크기를 고정하는 데 사용됩니다.
---
#### 2.15. 특정 요소 로드 대기 후 클릭 (WebDriverWait 심화)

*   **분기점**: `[테스트 페이지로 이동] -> [Start 버튼이 '클릭 가능한 상태가 될 때까지' 대기] -> [클릭] -> [결과 텍스트가 '나타날 때까지' 대기] -> [결과 출력]`
*   **설명**: `WebDriverWait`의 강력함을 보여주는 실전 예제입니다. `EC.element_to_be_clickable`은 요소가 화면에 보이는 것을 넘어, 실제로 '클릭할 수 있는 상태'가 될 때까지 기다립니다. 버튼을 누르면 로딩 바가 돌고 결과가 나중에 표시되는 동적 페이지를 자동화할 때 반드시 필요한 핵심 기술입니다.
---
#### 2.16. 드래그 앤 드롭 (`drag_and_drop`)

*   **분기점**: `[테스트 페이지로 이동] -> [액자(iframe) 안으로 전환] -> [끌어다 놓을 요소와 목표 지점 찾기] -> [마우스로 끌어서 목표 지점에 놓기]`
*   **설명**: `ActionChains`의 또 다른 강력한 기능입니다. `drag_and_drop(source, target)`은 소스(source) 요소를 마우스로 꾹 누른 채로 타겟(target) 요소 위치까지 끌고 가서 놓는 행동을 한 번에 실행해 줍니다.
---
#### 2.17. 웹 페이지 소스 코드 가져오기 (`page_source`)

*   **분기점**: `[구글 페이지로 이동] -> [현재 브라우저에 보이는 모든 HTML 코드 가져오기] -> [코드 앞 500자만 출력]`
*   **설명**: Selenium으로 동적 상호작용(스크롤, 클릭 등)을 모두 마친 후, 최종적으로 렌더링된 상태의 HTML 전체를 문자열로 가져옵니다. 이 소스를 이전에 배우셨던 `BeautifulSoup`에 넘겨주면, 정적 크롤링에서처럼 쉽고 강력하게 원하는 데이터를 파싱할 수 있습니다. **Selenium과 BeautifulSoup의 환상적인 조합**이 시작되는 지점입니다.
---
#### 2.18. 파일 업로드 자동화

*   **분기점**: `[파일 업로드 데모 페이지로 이동] -> [파일 선택 input 요소 찾기] -> [input 요소에 '업로드할 파일의 전체 경로'를 타이핑]`
*   **설명**: 파일 업로드를 자동화하는 매우 흥미로운 방법입니다. `<input type="file">` 형태의 요소는 클릭해서 파일 탐색기 창을 띄우는 대신, `.send_keys()`를 이용해 '업로드할 파일의 절대 경로'를 텍스트처럼 입력해주면 파일이 자동으로 첨부됩니다.

---

### 3. 주요 학습 포인트

*   **`driver`는 만능 리모컨**: 모든 자동화는 `driver` 객체를 통해 이루어집니다. 이 리모컨으로 브라우저의 거의 모든 것을 제어할 수 있습니다.
*   **'기다림'은 선택이 아닌 필수**: 현대 웹은 동적이므로, 코드 중간중간에 적절한 '대기'를 넣는 것은 오류를 방지하고 안정적인 자동화 코드를 만드는 핵심입니다. 특히 **`WebDriverWait` (명시적 대기) 사용을 습관화**하는 것이 매우 중요합니다.
*   **정확한 '요소 찾기'가 관건**: 내가 원하는 버튼, 입력창을 정확하게 지목하는 것이 자동화의 성패를 좌우합니다. `id`, `name`, `class_name`, `css_selector`, `xpath` 등 다양한 방법을 상황에 맞게 사용할 줄 알아야 합니다.
*   **Selenium은 사용자 행동 시뮬레이터**: Selenium의 본질은 사람의 행동(클릭, 타이핑, 스크롤, 마우스 이동 등)을 코드로 흉내 내는 것입니다. "사람이라면 어떻게 할까?"를 생각하면 자동화 로직을 짜기 수월합니다.
*   **Selenium과 BeautifulSoup의 협력**: Selenium으로 복잡한 동적 페이지를 최종 상태로 만든 후, `page_source`를 `BeautifulSoup`으로 분석하는 것은 복잡한 크롤링 작업을 매우 효율적으로 만드는 최고의 조합입니다.